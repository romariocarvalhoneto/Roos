# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Oco
                                 A QGIS plugin
 Faz layout das ocorrencias. morfo. pranchas e relatorio
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-02-24
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Romario Moraes Carvalho Neto
        email                : romariocarvalho@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software. you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation. either version 2 of the License. or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QVariant
from qgis.PyQt.QtGui import QIcon, QPixmap, QTransform
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QDialogButtonBox
from qgis.core import (edit, QgsField, QgsPoint, QgsGeometryUtils, QgsVectorLayer,
                     QgsFeature, QgsGeometry, QgsProject, QgsSvgMarkerSymbolLayer,
                     QgsVectorFileWriter, QgsFillSymbol, QgsRendererCategory, QgsTextFormat,
                     QgsCategorizedSymbolRenderer, QgsPalLayerSettings, QgsVectorLayerSimpleLabeling,
                     QgsPrintLayout, QgsReadWriteContext, QgsLayoutItemLabel, QgsLayoutItemPicture)
from qgis.PyQt.QtXml import QDomDocument
from qgis import processing
from qgis.utils import iface
#from qgis.PyQt import QtGui
#from PyQt5.QtWidgets import QMessageBox

import ast, re, math, mimetypes
import imghdr  #filetype, csv
#from exif import Image
from os import listdir, path  #, getcwd
from os.path import isfile, join

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .oco_dialog import OcoDialog
import os.path
#from .magnifier import Magnifier


class Oco:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Oco_{}.qm',format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        #self.menu = self.tr(u'&Oco e Morfo')
        self.menu = self.tr(u'&Roos')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str. QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker.PyArgumentList.PyCallByClass
        return QCoreApplication.translate('Oco', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/oco/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Oco e Morfo'),
            callback=self.run,
            parent=self.iface.mainWindow())

        ### ADICIONAR NOVOS 'plugins' ao menu
        icon_path = ':/plugins/oco/iconCOORD.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Coordenadas° na Tabela'),
            # callback=CoordAT,
            callback=self.testeFun,
            add_to_toolbar=False,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def testeFun(self):
        # from .coord_attributable.coord_attributable_dialog import CoordATDialog
        # CoordATDialog(self.iface.mainWindow()).exec_()  
        from .coord_attributable.coord_attributable import CoordAT
        CoordAT(self.iface.mainWindow()).run()
        #print("Rodou")
        
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                #self.tr(u'&Oco e Morfo')
                self.tr(u'&Roos'),
                action)
            self.iface.removeToolBarIcon(action)

    def changePhotoForward(self, controle): #ativado apos fotos carregadas
        if controle != 0:
            self.memorizar(controle-1) #chamar sempre essa funçao antes de mudar o controle, assim salva o estado certo
        
        self.carregarMemCheckBox(controle, 1)

        self.angulo = 90
        if controle < len(self.onlyImages):
            endereco_photo = self.onlyImages[controle]
            nome_photo = self.imagesNames[controle]
            self.dlg.label_nome_foto.setText(nome_photo)
            self.selectPoint(nome_photo)
            self.new_photo = QPixmap(endereco_photo)
            self.dlg.photo.setPixmap(self.new_photo)
            self.dlg.pushButton_2.setEnabled(True)
            self.controle_pagina += 1
            if self.controle_pagina == len(self.onlyImages):
                self.dlg.pushButton.setEnabled(False)
                self.dlg.button_box.setEnabled(True)
            if self.controle_pagina == 1:
                self.dlg.pushButton_2.setEnabled(False)
        else:
            print('erro changePhotoForward')

    def changePhotoBackward(self, controle): #ativado apos a segunda foto
        self.memorizar(controle-1) #chamar sempre essa funçao antes de mudar o controle, assim salva o estado certo
        self.carregarMemCheckBox(controle-1, -1)

        self.angulo = 90
        if controle > 1:
            foto_anterior = controle-2 #pq 0 é o inicio. 1 a primeira foto. 2 a segunda. só daí se volta
            endereco_photo = self.onlyImages[foto_anterior]
            nome_photo = self.imagesNames[foto_anterior]
            self.dlg.label_nome_foto.setText(nome_photo)
            self.selectPoint(nome_photo)
            self.new_photo = QPixmap(endereco_photo)
            self.dlg.photo.setPixmap(self.new_photo)
            self.controle_pagina -= 1
            if self.controle_pagina == 1:
                self.dlg.pushButton_2.setEnabled(False)
            if self.controle_pagina == len(self.onlyImages)-1:
                self.dlg.pushButton.setEnabled(True)
        else:
            print('erro changePhotoBackward')

    def loadAndFreezeQgsFileWidget(self):  #roda apenas uma vez
        #self.dlg.label_3.clear()
        self.dlg.pushButton_3.setEnabled(True)
        self.dlg.mQgsFileWidget.setReadOnly(1)
        self.dlg.pushButton.setEnabled(True)
        self.changePhotoForward(self.controle_pagina)
        self.dlg.groupBox_oco_margem.setEnabled(True)
        self.dlg.groupBox_oco_leito.setEnabled(True)
        self.dlg.groupBox_morfo.setEnabled(True)
        self.dlg.mMapLayerComboBox.setEnabled(False)
        self.dlg.mMapLayerComboBox_2.setEnabled(False)
        self.dlg.mMapLayerComboBox_3.setEnabled(False)
        self.dlg.mMapLayerComboBox_4.setEnabled(False)
        self.dlg.larg_M_LineEdit.setEnabled(False)
        self.dlg.mQgsDoubleSpinBox.setEnabled(False)
        self.dlg.comboBox_atr.setEnabled(False)
        #self.dlg.button_box.setEnabled(True)
        # self.dlg.label_quanti_fotos.clear()
        # self.dlg.label_quanti_pts.clear()
        
        if 'memoria.roos' in self.onlyfiles:
            box = QMessageBox()
            box.setIcon(QMessageBox.Question)
            box.setWindowTitle('Memoria Existente')
            box.setText('''Existe uma memória de trabalho anterior. Deseja carregá-la?\n
OBS: Se a opção 'NÃO' for escolhida, a memória do trabalho antigo será sobrescrita. Portanto, mude o nome do arquivo antigo caso deseje preservá-lo.''')
            box.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
            buttonY = box.button(QMessageBox.Yes)
            buttonY.setText('SIM')
            buttonN = box.button(QMessageBox.No)
            buttonN.setText('NÃO')
            box.exec_()
            if box.clickedButton() == buttonY:
                self.viagemTempo()
            elif box.clickedButton() == buttonN:
                pass
    
    def selectPoint(self, nomePhoto):
        '''Seleciona o ponto e adiciona seu nome ao GUI baseado no nome da foto'''
        atributo_guia = self.dlg.comboBox_atr.currentText()
        vetor_pts_Esquerda = self.dlg.mMapLayerComboBox_2.currentLayer()
        vetor_pts_Esquerda.removeSelection()
        vetor_pts_Direita = self.dlg.mMapLayerComboBox_4.currentLayer()
        vetor_pts_Direita.removeSelection()
        numero = []

        for letra in nomePhoto:
            if letra.isdigit(): 
                numero.append(letra)
        n_foto = ''.join(numero)

        n_fotos_Esquerda = [ str(pt[atributo_guia]) for pt in vetor_pts_Esquerda.getFeatures() ]
        if n_foto in n_fotos_Esquerda:
            for pts in vetor_pts_Esquerda.getFeatures():
                if str(pts[atributo_guia]) == n_foto:
                    self.dlg.label_nome_ponto.setText(f"Ponto {str(pts[self.seq])} Esquerda")
                    vetor_pts_Esquerda.select([pts.id()])

        else:
            for pts in vetor_pts_Direita.getFeatures():
                if str(pts[atributo_guia]) == n_foto:
                    self.dlg.label_nome_ponto.setText(f"Ponto {str(pts[self.seq])} Direita")
                    vetor_pts_Direita.select([pts.id()])

    def loadPhotos(self):

        # funçao dentro da função. Para ordenar as fotos conforme os numers que estão no string
        # import re
        def atoi(text):
            return int(text) if text.isdigit() else text

        def natural_keys(text):
            '''
            alist.sort(key=natural_keys) sorts in human order
            http://nedbatchelder.com/blog/200712/human_sorting.html
            (See Toothy's implementation in the comments)
            '''
            return [ atoi(c) for c in re.split(r'(\d+)', text) ]

        # alist=[
        #     "something1",
        #     "something12",
        #     "something17",
        #     "something2",
        #     "something25",
        #     "something29"]

        # alist.sort(key=natural_keys)
        # print(alist)

        self.onlyImages = []
        self.imagesNames = []
        #try:
        mypath = self.dlg.mQgsFileWidget.filePath()  #getcwd()
        self.onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))] #lista se for file
        self.onlyfiles.sort(key=natural_keys)

        for f in self.onlyfiles:
            if imghdr.what(f'{mypath}//{f}'):     #filetype.is_image(f):
                self.onlyImages.append(f'{mypath}//{f}')
                self.imagesNames.append(f)
                self.mem.append([[2],[]])  #para cada foto, add lista oco e morfo. (2 é um valor != 0 (False) ou 1(True))
                lista_zeros = [0 for comboBox in range(self.quanti_checkBox_leito)]
                self.mem_adicional.append(lista_zeros) #para cada foto, add lista das posições conforme combobox de leito
        #except:
            #print('erro ao carregar as imagens') 

    def photoTurn(self):  #exemplo em: C:\Users\AORUS\AppData\Roaming\QGIS\QGIS3\profiles\Romario\python\plugins\oco
        transf = QTransform()
        transf.rotate(self.angulo)
        rotated = self.new_photo.transformed(transf, mode=Qt.SmoothTransformation)
        self.dlg.photo.setPixmap(rotated)
        self.angulo += 90

    def memorizar(self, controle): #chamar sempre essa funçao antes de mudar o controle, assim salva o estado certo
        #print('memoria antes', self.mem)
        #--oco--
        lista_selecoes = [box.isChecked() for box in self.lista_checkBox]
        self.mem[controle].pop(0) #arranca lista inteira e substitui
        self.mem[controle].insert(0,lista_selecoes)
        lista_sel_combobox_leito = [box.currentIndex() for box in self.lista_comboBox]
        self.mem_adicional.pop(controle)
        self.mem_adicional.insert(controle,lista_sel_combobox_leito)
        #--morfo--
        lista_selecoes_morfo = [button.isChecked() for button in self.lista_radioButtons]
        self.mem[controle].pop(1) #arranca lista inteira e substitui
        self.mem[controle].insert(1,lista_selecoes_morfo)
        #print('memoria depois', self.mem)
        self.writeMemRoos()
        
    def zerarCheckBox(self):
        '''limpa todos os checkBox e comboBox'''
        for box in self.lista_checkBox:
            box.setChecked(False)
        for comboBox in self.lista_comboBox:
            comboBox.setCurrentIndex(0)
        for radioButton in self.lista_radioButtons:
            radioButton.setChecked(False)

    def carregarMemCheckBox(self, controle, frente_tras):
        '''marca os checkbox e carrega combobox conforme a memoria'''
        if 2 in self.mem[controle][0]: #[0]: #se for a primeira vez de todas
            self.zerarCheckBox()
        else:
            #carrega anterior se botão pra tras: (ou o contrário?)
            if frente_tras == 1:  #1 frente
                cont = 0
                for box in self.lista_checkBox:
                    box.setChecked(self.mem[controle][0][cont])   #[0][cont])
                    cont += 1
                cont_box = 0
                for comboBox in self.lista_comboBox:
                    comboBox.setCurrentIndex(self.mem_adicional[controle][cont_box])
                    cont_box += 1
                cont_radio = 0
                for radioButton in self.lista_radioButtons:
                    radioButton.setChecked(self.mem[controle][1][cont_radio])   #[0][cont])
                    cont_radio += 1

            #carrega proxima se botao frente (ou o contrário?)
            elif frente_tras == -1:  #-1 tras
                cont = 0
                for box in self.lista_checkBox:
                    box.setChecked(self.mem[controle-1][0][cont])  #[0][cont])
                    cont += 1
                cont_box = 0
                for comboBox in self.lista_comboBox:
                    comboBox.setCurrentIndex(self.mem_adicional[controle-1][cont_box])
                    cont_box += 1
                cont_radio = 0
                for radioButton in self.lista_radioButtons:
                    radioButton.setChecked(self.mem[controle-1][1][cont_radio])   #[0][cont])
                    cont_radio += 1

    def inicial_fotos(self):
        '''Quantidade de Fotos''' 
        self.loadPhotos()
        self.quanti_fotos = len(self.imagesNames)
        texto = f'Total de Fotos: {self.quanti_fotos}'
        self.dlg.label_quanti_fotos.setText(texto)
        self.confirmacao()
        #self.loadAndFreezeQgsFileWidget()
    
    def confirmacao(self):
        '''Confirma se todos foram carregados'''
        if self.quanti_fotos == self.dlg.quati_pts:
            box = QMessageBox()
            box.setIcon(QMessageBox.Question)
            box.setWindowTitle('Dados Aprovados')
            box.setText('''A quantidade de fotos e de pontos são iguais. Prosseguir?\n
OBS: Caso hajam shapes de ocorrencias e/ou morfos antigas na pasta, estes devem ser removidos da pasta para serem preservados pois serão modificados.''')
            box.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
            buttonY = box.button(QMessageBox.Yes)
            buttonY.setText('SIM')
            buttonN = box.button(QMessageBox.No)
            buttonN.setText('NÃO')
            box.exec_()
            if box.clickedButton() == buttonY:
                #self.writeMemRoos()
                self.loadAndFreezeQgsFileWidget()
            elif box.clickedButton() == buttonN:
                self.dlg.mQgsFileWidget.blockSignals(True)
                self.dlg.mQgsFileWidget.lineEdit().clearValue() 
                #self.dlg.mQgsFileWidget.setEnabled(False)
                self.dlg.mQgsFileWidget.blockSignals(False)

        else:
            message = f'A quantidade de fotos é {self.quanti_fotos} e de pontos é {self.dlg.quati_pts}. \nDevem ser iguais.'
            QMessageBox.critical(self.dlg,'Inconsistência nos Dados', message)
            self.dlg.mQgsFileWidget.blockSignals(True)
            self.dlg.mQgsFileWidget.lineEdit().clearValue() 
            self.dlg.mQgsFileWidget.blockSignals(False)

    def perpendicular(self, pontos, linha): #(vetorPontos, vetorLinha)
        #essa funçao pega cada linha da margem e mede a distancia ao ponto (linha perpendicular), pegando a menor distancia no fim)
        l_intersects = [] # para conter os objetos da intersecção linha-margem
        pts = pontos.getFeatures()
        l_dist_pts = []  #lista das distancias

        ln = linha.getFeatures()
        l_linhas = []
        for l in ln: #linhas da margem
            polyLine = l.geometry().asMultiPolyline()

            cont_p = 0
            for p in pts:
                l_dist_pts.append([]) #lista com valor das distancias, para encontrar a menor
                l_linhas.append([]) #lista contendo as linhas (objetos)
                l_intersects.append([])
                for pts_ln in polyLine[0]:
                    if polyLine[0].index(pts_ln) == 0: # se for o primeiro ponto das polilinhas
                        pontoInicial = QgsPoint(pts_ln)
                    else:
                        ponto = QgsPoint(p.geometry().asPoint())
                        pontoFinal = QgsPoint(pts_ln)

                        line = QgsGeometryUtils.perpendicularSegment(ponto, pontoInicial, pontoFinal) #(pont qq, pontoInicial do segmento, pontoFinal do mesmo segemnto)

                        pt_inicio = line.startPoint()
                        pt_fim = line.endPoint()

                        PointList = [pt_inicio, pt_fim]

                        #estender a linha para certamente encostar na margem
                        ln_extend = QgsVectorLayer(f"LineString?crs=epsg:31982&field={self.atributo_guia}&field={self.seq}:integer&index=yes","menor dist","memory")
                        ln_extend.startEditing()
                        feature2 = QgsFeature()                                             ### ajuste da distancia em que a oco da MARGEM ficará da linha de margem.
                        feature2.setGeometry(QgsGeometry.fromPolyline(PointList).extendLine(self.largura_media*0.05, self.largura_media*0.05)) #line.length()*0.1,line.length()*0.1)) <=====   AJUSTE  <=====
                        feature2.setAttributes([int(p[self.atributo_guia]), int(p[self.seq])])  #adiciona o valor de id (ou nome) equivalente ao ponto
                        ln_extend.addFeature(feature2)
                        ln_extend.commitChanges()

                        #QgsProject.instance().addMapLayer(ln_extend)

                        pontoInicial = pontoFinal

                        #-------- intersection
                        try:
                            intersect_ponto = processing.run("native:lineintersections", {'INPUT':ln_extend,
                                                            'INTERSECT':linha,
                                                            'INPUT_FIELDS':[],
                                                            'INTERSECT_FIELDS':[],
                                                            'INTERSECT_FIELDS_PREFIX':'',
                                                            'OUTPUT':'TEMPORARY_OUTPUT'})
                            geom = intersect_ponto['OUTPUT'].getFeature(1).geometry()
                            if geom:
                                geom_pt = p.geometry()
                                dist_m = geom_pt.distance(geom)
                                l_dist_pts[cont_p].append(dist_m)
                                l_linhas[cont_p].append(ln_extend)  
                                l_intersects[cont_p].append(intersect_ponto['OUTPUT'])
                                #QgsProject.instance().addMapLayer(intersect_ponto['OUTPUT'])
                        except :
                            print("Exception perpendicular intersection ") #pontos podem coincidir sobre a linha
                            pass
                cont_p += 1

        lista_ln_final = [] #lista que conterá as menores linhas
        lista_intersect_final = []
        cont = 0
        for pt in l_dist_pts:
            menor_dist = min(pt)
            indice_menor_item = l_dist_pts[cont].index(menor_dist)
            lista_ln_final.append(l_linhas[cont][indice_menor_item])
            #QgsProject.instance().addMapLayer(l_linhas[cont][indice_menor_item]) ##linha selecionada
            lista_intersect_final.append(l_intersects[cont][indice_menor_item])
            cont += 1
        
        return lista_ln_final, lista_intersect_final

    def perpendicularBuffer(self, pontos, linha, offset): #pontos_sobre_margem, linha_de_margem, offset margem margem
        ''' Cria linhas perpendiculares dentro de um buffer, sobre pontos que estão em um dos limites deste buffer'''
        #precisa de pontos sobre a margem
        pts = pontos.getFeatures()
        l_dist_pts = []  #lista das distancias

        ln = linha.getFeatures()
        l_linhas = []
        for l in ln:
            polyLine = l.geometry().asMultiPolyline()
            cont_p = 0
            for p in pts:
                l_dist_pts.append([])
                l_linhas.append([])
                for pts_ln in polyLine[0]:
                    if polyLine[0].index(pts_ln) == 0: # se for o primeiro ponto das polilinhas
                        pontoInicial = QgsPoint(pts_ln)
                    else:
                        ponto = QgsPoint(p.geometry().asPoint())
                        pontoFinal = QgsPoint(pts_ln)

                    # nessa parte do processo, essa linha pode se tornar praticamente inesistente pois.
                    # como o ponto está sobre a linha (ele é praticamente o meio da linha), uma linha perpendicular
                    # aos extremos, seria praticamente um ponto

                        line = QgsGeometryUtils.perpendicularSegment(ponto, pontoInicial, pontoFinal)

                        pt_inicio = line.startPoint()
                        pt_fim = line.endPoint()

                        PointList = [pt_inicio, pt_fim]

                        #estender para a menor linha certamente encostar no buffer
                        ln_extend = QgsVectorLayer(f"LineString?crs=epsg:31982&field={self.atributo_guia}&field={self.seq}:integer&index=yes","menor dist","memory")
                        ln_extend.startEditing()
                        feature2 = QgsFeature()
                        feature2.setGeometry(QgsGeometry.fromPolyline(PointList).extendLine(self.largura_media, self.largura_media)) #55,55)) 
                        feature2.setAttributes([int(p[self.atributo_guia]), int(p[self.seq])])
                        ln_extend.addFeature(feature2)
                        ln_extend.commitChanges()

                        #QgsProject.instance().addMapLayer(ln_extend)
                        
                        pontoInicial = pontoFinal

                        #-------- intersection
                        try:
                            intersect_ponto = processing.run("native:lineintersections", {'INPUT':ln_extend,
                                                        'INTERSECT':offset,
                                                        'INPUT_FIELDS':[],
                                                        'INTERSECT_FIELDS':[],
                                                        'INTERSECT_FIELDS_PREFIX':'',
                                                        'OUTPUT':'TEMPORARY_OUTPUT'})

                            geom = intersect_ponto['OUTPUT'].getFeature(1).geometry()
                            if geom:
                                geom_pt = p.geometry()
                                dist_m = geom_pt.distance(geom) #distancia do ponto da intersecao até a margem
                                l_dist_pts[cont_p].append(dist_m)
                                l_linhas[cont_p].append(ln_extend)

                        except :
                            print('Exception buffer lines')
                            pass

                cont_p += 1

        lista_ln_final = []
        cont = 0
        for pt in l_dist_pts:
                    #TODO: deverá existir uma forma de achar a menor distancia entrando apenas com a margem e o ponto, 
                    # sem ter que achar a distancias de todos os seguimentos da linha.
            menor_dist = min(pt)
            indice_menor_item = l_dist_pts[cont].index(menor_dist)
            lista_ln_final.append(l_linhas[cont][indice_menor_item])
            cont += 1
        
        return lista_ln_final

    def linhasAreaFoto(self, pontos, linha, offset): #pontos são as intersecções foto-margem e linha é a margem
        ## não esquecer de ordenar os pontos antes de entrar aqui
        '''Faz o pre-processamento necessário para aqui mesmo chamar perpendicularBuffer()'''
        l_intersects_meio = [] # para conter os objetos da intersecção linha-margem
        pts = [i.getFeature(1) for i in pontos]
        ln = linha.getFeatures()

        cont_p = 0
        for p in pts:
            if cont_p == 0: # se for o primeiro ponto das polilinhas
                pt_inicio = QgsPoint(p.geometry().asPoint())
                cont_p += 1
            else:
                pt_fim = QgsPoint(p.geometry().asPoint())

                PointList = [pt_inicio, pt_fim]

                ln = QgsVectorLayer(f"LineString?crs=epsg:31982&field={self.atributo_guia}&field={self.seq}:integer&index=yes","ln","memory")
                ln.startEditing()
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPolyline(PointList)) 
                feature.setAttributes([int(p[self.atributo_guia]), int(p[self.seq])])
                ln.addFeature(feature)
                ln.commitChanges()

                #QgsProject.instance().addMapLayer(ln)

                #marcar o meio da linha entre uma intersecçao e outra
                meio_linha = processing.run("native:centroids", {'INPUT': ln,
                                                                'OUTPUT': 'TEMPORARY_OUTPUT'})
                l_intersects_meio.append(meio_linha['OUTPUT'])                                           
                #QgsProject.instance().addMapLayer(meio_linha['OUTPUT'])

                pt_inicio = pt_fim
                cont_p += 1
        
        # juntar todos os intersetcs_meio de linha em um layer mesclado (merge) para usar perpendicular() aqui
        vetor_pts_intersects_meio = processing.run("native:mergevectorlayers", {'LAYERS':l_intersects_meio,
                                                                                'CRS':None,
                                                                                'OUTPUT':'TEMPORARY_OUTPUT'})

        #QgsProject.instance().addMapLayer(vetor_pts_intersects_meio['OUTPUT'])
        lista_linhas, lista_intersects = self.perpendicular(vetor_pts_intersects_meio['OUTPUT'], linha) # aqui vai fazer linhas perpendiculares 
                                        # a margem quando o ponto não estiver sobre a linha, ou seja, vai ajustar o ponto do meio à margem

        # for i in lista_intersects:
        #     QgsProject.instance().addMapLayer(i)

        # faz um merge para todos os pontos ajustados serem usados na perpendicularBuffer() e daí sim trazer as linhas limites
        vetor_pts_intersects_meio_ajustado = processing.run("native:mergevectorlayers", {'LAYERS':lista_intersects,
                                                                                'CRS':None,
                                                                                'OUTPUT':'TEMPORARY_OUTPUT'})
        
        #QgsProject.instance().addMapLayer(vetor_pts_intersects_meio_ajustado['OUTPUT'])

        # criar linha perpendicular até a borda do buffer
        lista_linhas_limite = self.perpendicularBuffer(vetor_pts_intersects_meio_ajustado['OUTPUT'], linha, offset)
        # for i in lista_linhas_limite:
        #     QgsProject.instance().addMapLayer(i)

        return lista_linhas_limite

    def bufferNumerado(self, margem, SIDE, lista_linhas_buffer, lista_dist_pts_margem, vetor_pts): # SIDE = 0 (esquerda) OU 1 (direita)
        # faz o buffer. side 0 para a 'esquerda' e side 1 para 'direita'
        buffer_D = processing.run("qgis:singlesidedbuffer", {'INPUT':margem,
                                                        'DISTANCE':50,
                                                        'SIDE':SIDE,
                                                        'SEGMENTS':8,
                                                        'JOIN_STYLE':1,
                                                        'MITER_LIMIT':2,
                                                        'OUTPUT':'TEMPORARY_OUTPUT'}) #'memory:qqqoisa'
        #QgsProject.instance().addMapLayer(buffer_D['OUTPUT'])

        # ## ---> algoritmo mais veloz ("native:splitwithlines"), porém sempre vem com poligo a mais que precisa ser filtrados <---- ###
        # ## logo a baixo está lógica para filtrar, mas prefiro diminuir possibilidade de erro com mais demorado ("saga:polygonlineintersection")
        # for linha in lista_linhas_buffer:
        #     #QgsProject.instance().addMapLayer(linha)
        #     if linha is lista_linhas_buffer[0]:  # primeira vez 
        #         split = processing.run("native:splitwithlines", {'INPUT':buffer_D['OUTPUT'],
        #                                                         'LINES':linha,
        #                                                         'OUTPUT':'TEMPORARY_OUTPUT'})
        #         vetor_uniao = split['OUTPUT']
        #     else:
        #         split = processing.run("native:splitwithlines", {'INPUT':vetor_uniao,
        #                                                         'LINES':linha,
        #                                                         'OUTPUT':'TEMPORARY_OUTPUT'})
        #         vetor_uniao = split['OUTPUT']
        # #QgsProject.instance().addMapLayer(vetor_uniao)

        # if margem == self.dlg.mMapLayerComboBox.currentLayer(): #esquerda
        #     self.cont_morfo_E.append(1)
        #     #vetor_uniao = QgsVectorLayer(uniao, f'Morfo Margem Esquerda {len(self.cont_morfo_E)}', 'ogr')
        #     vetor_uniao.setName(f'Morfo Margem Esquerda {len(self.cont_morfo_E)}')
        # else: #direita
        #     self.cont_morfo_D.append(1)
        #     #vetor_uniao = QgsVectorLayer(uniao, f'Morfo Margem Direita {len(self.cont_morfo_D)}', 'ogr')
        #     vetor_uniao.setName(f'Morfo Margem Direita {len(self.cont_morfo_D)}')

        # #------------------------------------------------------------
        ### Filtrar os poligonos gerados erroneamente pelo split são deletados:
        # ## quantidade de pontos da direita:
        # feats_D = vetor_pts.getFeatures() 
        # quanti_pts_D = sum(1 for i in feats_D)

        # ## quantidade de poligonos no vetor_uniao:
        # feats_uniao = vetor_uniao.getFeatures()
        # quanti_pol_uniao = sum(1 for i in feats_uniao)

        # if quanti_pts_D != quanti_pol_uniao:
        #     #apagar geometrias muito pequenas
        #     with edit(vetor_uniao):
        #         for feat in vetor_uniao.getFeatures():
        #             #print(feat.geometry().area())
        #             if feat.geometry().area() < 50: ## considerando 50 m2, os poligonos gerados erroneamente pelo split são deletados 
        #                 vetor_uniao.deleteFeature(feat.id())
        #QgsProject.instance().addMapLayer(vetor_uniao)

        # ##------------------------------------------------------------

        ## TODO: VERIFICAR A FUNCIONALIDADE caso haja apenas um ponto.

        for linha in lista_linhas_buffer:
            #QgsProject.instance().addMapLayer(linha)
            if linha is lista_linhas_buffer[0]:  # primeira vez 
                split = processing.run("saga:polygonlineintersection", {'POLYGONS':buffer_D['OUTPUT'],
                                                                        'LINES':linha,
                                                                        'INTERSECT':'TEMPORARY_OUTPUT'})
                uniao = split['INTERSECT']
            else:
                split = processing.run("saga:polygonlineintersection", {'POLYGONS':uniao,
                                                                        'LINES':linha,
                                                                        'INTERSECT':'TEMPORARY_OUTPUT'})
                uniao = split['INTERSECT']
        
        if margem == self.dlg.mMapLayerComboBox.currentLayer(): #esquerda
            self.cont_morfo_E.append(1)
            vetor_uniao = QgsVectorLayer(uniao, f'Morfo Margem Esquerda {len(self.cont_morfo_E)}', 'ogr')
        else: #direita
            self.cont_morfo_D.append(1)
            vetor_uniao = QgsVectorLayer(uniao, f'Morfo Margem Direita {len(self.cont_morfo_D)}', 'ogr')

        ## usar as linhas para dar valor id e seq aos poligonos dentro do buffer
        #intersec = []  #para selecionar apenas
        with edit(vetor_uniao):
            listaFieldName = [ field.name() for field in vetor_uniao.fields()] #lista para armazenar os fields (cabecalho)
            if self.atributo_guia not in listaFieldName:
                vetor_uniao.dataProvider().addAttributes([QgsField(self.atributo_guia, QVariant.Int)]) #.Double)])
                vetor_uniao.updateFields()
            vetor_uniao.dataProvider().addAttributes([QgsField(self.seq, QVariant.Int)]) #.Double)])
            vetor_uniao.updateFields()
            listaFieldName = [ field.name() for field in vetor_uniao.fields()] #lista atualizada para armazenar os fields (cabecalho)
            for linha in lista_dist_pts_margem:
                for ln_feature in linha.getFeatures():
                    poligonos_morfo = vetor_uniao.getFeatures()  #QgsFeatureRequest().setFilterRect(pt_feature.geometry().boundingBox()))
                    for poligono in poligonos_morfo:
                        if ln_feature.geometry().intersects(poligono.geometry()):  #touches(area_feature.geometry()):
                            attrs = { listaFieldName.index(self.seq) : ln_feature.attribute(self.seq), 
                                    listaFieldName.index(self.atributo_guia) : ln_feature.attribute(self.atributo_guia) }
                            vetor_uniao.dataProvider().changeAttributeValues({ poligono.id() : attrs })
                            #intersec.append(poligono.id())

        # vetor_uniao.select(intersec) #para selecionar apenas
        return vetor_uniao
    
    # função que cria nova posição para o ponto da primeira oco. Usa a extremidade da linha perpendicular
    def ocoUm(self, dist_pt_margem): #, n_foto): #n_foto servirá para identificar se é foto da direita ou da esquerda
        #dist_pt_margem já possui n_foto e seq
        feat = dist_pt_margem.getFeature(1)
        n_foto = int(feat[self.atributo_guia])
        endPoint_ln_ate_margem = QgsPoint(feat.geometry().asPolyline()[1])
        nova_posicao = QgsVectorLayer(f"Point?crs=epsg:31982&field={self.atributo_guia}:integer&field={self.seq}:integer&field={'label'}:string&index=no",f"oco 1 ID {feat[self.atributo_guia]}","memory")
        nova_posicao.startEditing()
        feature2 = QgsFeature()
        feature2.setGeometry(endPoint_ln_ate_margem) 
        if n_foto in self.fotos_E: #Está na esquerda
            if feat[self.seq] < 10:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/E 0{feat[self.seq]}'])
            else:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/E {feat[self.seq]}'])
        else: #fotos_D
            if feat[self.seq] < 10:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/D 0{feat[self.seq]}'])
            else:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/D {feat[self.seq]}'])
        nova_posicao.addFeature(feature2)
        nova_posicao.commitChanges()
        #QgsProject.instance().addMapLayer(nova_posicao)

        return nova_posicao

    # função que cria nova posição para o ponto da oco (apartir da segunda oco, inclusa)
    def maisOco(self, dist_pt_margem, nova_distancia): #, n_foto): #(menor distancia entre ponto e margem, nova distancia desejada)
        feat = dist_pt_margem.getFeature(1)    
        n_foto = int(feat[self.atributo_guia])
        startPoint_ln_ate_margem = QgsPoint(feat.geometry().asPolyline()[0])
        endPoint_ln_ate_margem = QgsPoint(feat.geometry().asPolyline()[1])
        PointList = [startPoint_ln_ate_margem, endPoint_ln_ate_margem]

        ln_extend = QgsVectorLayer(f"LineString?crs=epsg:31982&field={self.atributo_guia}:integer&field={self.seq}:integer&field={'label'}:string&index=no","outra oco","memory")
        ln_extend.startEditing()
        feature2 = QgsFeature()
        feature2.setGeometry(QgsGeometry.fromPolyline(PointList).extendLine(0.0,nova_distancia)) #estender 30m do tamanho da linha, para ambos os lados
        if n_foto in self.fotos_E:
            if feat[self.seq] < 10:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/E 0{feat[self.seq]}'])
            else:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/E {feat[self.seq]}'])
        else:
            if feat[self.seq] < 10:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/D 0{feat[self.seq]}'])
            else:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/D {feat[self.seq]}'])

        ln_extend.addFeature(feature2)
        ln_extend.commitChanges()

        nova_posicao = QgsVectorLayer(f"Point?crs=epsg:31982&field={self.atributo_guia}:integer&field={self.seq}:integer&field={'label'}:string&index=no",f"nova oco {feat[self.atributo_guia]}","memory")
        endPoint_ln_extend = QgsPoint(ln_extend.getFeature(1).geometry().asPolyline()[1]) #posição final da estensão nova
        nova_posicao.startEditing()
        feature3 = QgsFeature()
        feature3.setGeometry(endPoint_ln_extend) #QgsGeometry.fromPolyline(PointList).extendLine(line.length()*0.1,line.length()*0.1)) #estender 10% do tamanho da linha, para ambos os lados
        if n_foto in self.fotos_E:
            if feat[self.seq] < 10:
                feature3.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/E 0{feat[self.seq]}'])
            else:
                feature3.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/E {feat[self.seq]}'])
        else:
            if feat[self.seq] < 10:
                feature3.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/D 0{feat[self.seq]}'])
            else:
                feature3.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'M/D {feat[self.seq]}'])
        nova_posicao.addFeature(feature3)
        nova_posicao.commitChanges()
        #QgsProject.instance().addMapLayer(nova_posicao)
        return nova_posicao

    # retorna uma lista com as linhas que vão do centro do leito até próximo à margem     
    def linhaOcoLeito(self, lista_dist_pt_margem, margem_proxima, margem_distante): #lista_dist_pts_margem_D

        lista_ln_final = []

        for dist_pt_margem in lista_dist_pt_margem:
            #pegar a interseção com a margem mais próxima;
            #-------- intersection
            intersect_ponto = processing.run("native:lineintersections", {'INPUT':dist_pt_margem,
                                            'INTERSECT':margem_proxima,
                                            'INPUT_FIELDS':[],
                                            'INTERSECT_FIELDS':[],
                                            'INTERSECT_FIELDS_PREFIX':'',
                                            'OUTPUT':'TEMPORARY_OUTPUT'})

            #QgsProject.instance().addMapLayer(intersect_ponto['OUTPUT'])

            #extender até o a outra margem;
            feat = dist_pt_margem.getFeature(1)    
            startPoint_ln_ate_margem = QgsPoint(feat.geometry().asPolyline()[0])
            endPoint_ln_ate_margem = QgsPoint(feat.geometry().asPolyline()[1])
            PointList = [startPoint_ln_ate_margem, endPoint_ln_ate_margem]

            ln_extend = QgsVectorLayer(f"LineString?crs=epsg:31982&field={self.atributo_guia}&field={self.seq}:integer&index=yes","extend outro lado","memory")
            ln_extend.startEditing()
            feature2 = QgsFeature()

            feature2.setGeometry(QgsGeometry.fromPolyline(PointList).extendLine(self.largura_media, self.largura_media)) #100, 100))  #estender o valor medio para cada lado
            # self.escala,self.escala ficou muito grande em um exemplo e acabou cortando o rio sinuoso mais de uma vez
            feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq])])
            ln_extend.addFeature(feature2)
            ln_extend.commitChanges()
            #QgsProject.instance().addMapLayer(ln_extend)

            #pegar as inteseções e criar a linha que servirá para posição da oco;
            #-------- intersection
            intersect_ponto2 = processing.run("native:lineintersections", {'INPUT':ln_extend,
                                            'INTERSECT':margem_distante,
                                            'INPUT_FIELDS':[],
                                            'INTERSECT_FIELDS':[],
                                            'INTERSECT_FIELDS_PREFIX':'',
                                            'OUTPUT':'TEMPORARY_OUTPUT'})

            #QgsProject.instance().addMapLayer(intersect_ponto2['OUTPUT'])

            feat_pt1 = intersect_ponto['OUTPUT'].getFeature(1).geometry()
            feat_pt2 = intersect_ponto2['OUTPUT'].getFeature(1).geometry()
            PointList_nova = [QgsPoint(feat_pt1.asPoint()), QgsPoint(feat_pt2.asPoint())]

            ln_margem_a_margem = QgsVectorLayer(f"LineString?crs=epsg:31982&field={self.atributo_guia}&field={self.seq}:integer&index=yes","margem a margem","memory")
            ln_margem_a_margem.startEditing()
            feature3 = QgsFeature()
            feature3.setGeometry(QgsGeometry.fromPolyline(PointList_nova))
            feature3.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq])])
            ln_margem_a_margem.addFeature(feature3)
            ln_margem_a_margem.commitChanges()
            #QgsProject.instance().addMapLayer(ln_margem_a_margem)

            # fazer linha até a metade 
            #marcar o meio da linha
            meio_linha = processing.run("native:centroids", {'INPUT': ln_margem_a_margem,
                                                            'OUTPUT': 'TEMPORARY_OUTPUT'})

            feat_pt1 = intersect_ponto['OUTPUT'].getFeature(1).geometry()
            feat_pt2 = meio_linha['OUTPUT'].getFeature(1).geometry()
            PointList_metade = [QgsPoint(feat_pt1.asPoint()), QgsPoint(feat_pt2.asPoint())]

            ln_margem_a_metade = QgsVectorLayer(f"MultiLineString?crs=epsg:31982&field={self.atributo_guia}&field={self.seq}:integer&index=yes","margem a metade","memory")
            ln_margem_a_metade.startEditing()
            feature3 = QgsFeature()
            linha_geom = QgsGeometry.fromPolyline(PointList_metade)
            feature3.setGeometry(linha_geom) #.extendLine(linha_geom.length()*0.1, 30)) #entregar pronta pra usa da extremidade, como em perpendicular()
            feature3.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq])])
            ln_margem_a_metade.addFeature(feature3)
            ln_margem_a_metade.commitChanges()
            #QgsProject.instance().addMapLayer(ln_margem_a_metade)
            #print(linha_geom.length())


            #----buffer do ponto para cortar linhas margem-ao-meio-de-leito
            distacia_buffer = self.tamanhoPontos*1.5 # pareceu bem colocado o elemento em A ou E   <=====   AJUSTE  <=====
            buffer_margem = processing.run("native:buffer", {'INPUT': intersect_ponto['OUTPUT'],
                                                            'DISTANCE': distacia_buffer,
                                                            'SEGMENTS': 20,
                                                            'END_CAP_STYLE': 0, 
                                                            'JOIN_STYLE': 0,
                                                            'MITER_LIMIT': 2,
                                                            'DISSOLVE': False,
                                                            'OUTPUT': 'TEMPORARY_OUTPUT'})
            #QgsProject.instance().addMapLayer(buffer_margem['OUTPUT'])

            #-------cortar linha margem à metade pelo buffer da margem:
            trim = processing.run("native:difference", {'INPUT':ln_margem_a_metade,
                                                'OVERLAY':buffer_margem['OUTPUT'],
                                                'OUTPUT':'TEMPORARY_OUTPUT'})

            geom = trim['OUTPUT'].getFeature(1).geometry()
            if geom:
            #QgsProject.instance().addMapLayer(trim['OUTPUT'])
                lista_ln_final.append(trim['OUTPUT'])
            else:
                lista_ln_final.append(ln_margem_a_metade)

        return lista_ln_final

    # caso haja pontos sobrepostos, mudar manualmente 
    def ocoLeito(self, ln_leito, posicaoABCDE):  
        feat = ln_leito.getFeature(1) #linha
        n_foto = int(feat[self.atributo_guia])
        
        if posicaoABCDE == 0:
            ## --- A ou E-----:
            #print(feat.geometry().asMultiPolyline()[0][0])
            startPoint_ln_ate_margem = QgsPoint(feat.geometry().asMultiPolyline()[0][0])
            nova_posicao = QgsVectorLayer(f"Point?crs=epsg:31982&field={self.atributo_guia}:integer&field={self.seq}:integer&field=label:string&index=no","Leito A ou E","memory")
            nova_posicao.startEditing()
            feature2 = QgsFeature()
            feature2.setGeometry(startPoint_ln_ate_margem)
            if n_foto in self.fotos_E: #A se for esquerda
                if feat[self.seq] < 10:
                    feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/A 0{feat[self.seq]}'])
                else:
                    feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/A {feat[self.seq]}'])
            else: #E se direita
                if feat[self.seq] < 10:
                    feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/E 0{feat[self.seq]}'])
                else:
                    feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/E {feat[self.seq]}'])
            nova_posicao.addFeature(feature2)
            nova_posicao.commitChanges()
            #QgsProject.instance().addMapLayer(nova_posicao)

        elif posicaoABCDE == 1:
            ## --- B ou D-----:
            ### pegar o centro da linha
            geo = feat.geometry()
            centro = geo.centroid()
            nova_posicao = QgsVectorLayer(f"Point?crs=epsg:31982&field={self.atributo_guia}:integer&field={self.seq}:integer&field=label:string&index=no","Leito B ou D","memory")
            nova_posicao.startEditing()
            feature2 = QgsFeature()
            feature2.setGeometry(centro)
            if n_foto in self.fotos_E: #B se for esquerda
                if feat[self.seq] < 10:
                    feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/B 0{feat[self.seq]}'])
                else:
                    feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/B {feat[self.seq]}'])
            else: #D se direita
                if feat[self.seq] < 10:
                    feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/D 0{feat[self.seq]}'])
                else:
                    feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/D {feat[self.seq]}'])
            
            nova_posicao.addFeature(feature2)
            nova_posicao.commitChanges()

        elif posicaoABCDE == 2:
            ## --- C -----:
            endPoint_ln_ate_margem = QgsPoint(feat.geometry().asMultiPolyline()[0][1])
            nova_posicao = QgsVectorLayer(f"Point?crs=epsg:31982&field={self.atributo_guia}:integer&field={self.seq}:integer&field=label:string&index=yes","Leito C","memory")
            nova_posicao.startEditing()
            feature2 = QgsFeature()
            feature2.setGeometry(endPoint_ln_ate_margem) 
            if feat[self.seq] < 10:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/C 0{feat[self.seq]}'])
            else:
                feature2.setAttributes([int(feat[self.atributo_guia]), int(feat[self.seq]), f'L/C {feat[self.seq]}'])
            nova_posicao.addFeature(feature2)
            nova_posicao.commitChanges()
            #QgsProject.instance().addMapLayer(nova_posicao)
        
        return nova_posicao

    def showLabel(self, layer, string_field):
        layer_settings = QgsPalLayerSettings()
        text_format = QgsTextFormat()
        # text_format.setFont(QFont("Arial", 12))
        text_format.setSize(self.tamanhoPontos) #text_format.setSize(12)
        # buffer_settings = QgsTextBufferSettings()
        # buffer_settings.setEnabled(True)
        # buffer_settings.setSize(1)
        # buffer_settings.setColor(QColor("white"))
        # text_format.setBuffer(buffer_settings)
        layer_settings.setFormat(text_format)
        layer_settings.fieldName = string_field #"Altura"
        layer_settings.dist = 2
        if string_field == "Altura":
            layer.renderer().symbol().setSize(0)
            layer_settings.placement = 1  #offset from point
        #layer_settings.enabled = True
        layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
        layer.setLabelsEnabled(True)
        layer.setLabeling(layer_settings)
        layer.triggerRepaint()

    def simbologiaSVG(self, layer, nomeFiguraSVG): # layer = self.ocoUm(lista_ordem_todas_ln_perp[cont_foto]), nomeFiruraSVG = 'viva_margem.svg'
        #saving layer
        try:
            save_options = QgsVectorFileWriter.SaveVectorOptions()
            save_options.driverName = "ESRI Shapefile"
            save_options.fileEncoding = "UTF-8"
            transform_context = QgsProject.instance().transformContext()
            layer_path = os.path.abspath(self.pasta_vetor_pts) #C:/Users/Dell/Desktop/Projetos/oco/Oco_plugin/Banco OCO/SHP
            write_layer = QgsVectorFileWriter.writeAsVectorFormatV2(layer,
                                                            f'{layer_path}\\{nomeFiguraSVG[:-4]}',
                                                            transform_context,
                                                            save_options)
            path = f'{self.plugin_dir}\\imagens\\{nomeFiguraSVG}'  #'C:\\Program Files\\QGIS 3.10\\apps\\qgis-ltr\\svg\\oco\\viva_margem.svg'
            fig_svg = QgsSvgMarkerSymbolLayer(path)
            fig_svg.setSize(self.tamanhoPontos)
            #fig_svg.setStrokeWidth(1)
            new_Layer = QgsVectorLayer(f'{layer_path}\\{nomeFiguraSVG[:-4]}.shp', nomeFiguraSVG[:-4], "ogr")
            new_Layer.renderer().symbol().changeSymbolLayer(0, fig_svg )
            QgsProject.instance().addMapLayer(new_Layer)
            self.showLabel(new_Layer, "label")
            #new_Layer.triggerRepaint()

        except :
            ## temporário
            print('Except: Erro simbologiaSVG')
            layer.setName(nomeFiguraSVG[:-4])
            path = f'{self.plugin_dir}\\imagens\\{nomeFiguraSVG}'  #'C:\\Program Files\\QGIS 3.10\\apps\\qgis-ltr\\svg\\oco\\viva_margem.svg'
            fig_svg = QgsSvgMarkerSymbolLayer(path)
            fig_svg.setSize(self.tamanhoPontos)
            #fig_svg.setStrokeWidth(1)
            layer.renderer().symbol().changeSymbolLayer(0, fig_svg )
            QgsProject.instance().addMapLayer(layer)
            self.showLabel(layer, "label")
            #layer.triggerRepaint()

    def simbologiaSVGTemp(self, layer, nomeFiguraSVG):
        '''Será rodada apenas se houver erro no merge das oco, para que cada oco apareça'''
        ## temporário
        path = f'{self.plugin_dir}\\imagens\\{nomeFiguraSVG}'  #'C:\\Program Files\\QGIS 3.10\\apps\\qgis-ltr\\svg\\oco\\viva_margem.svg'
        fig_svg = QgsSvgMarkerSymbolLayer(path)
        fig_svg.setSize(self.tamanhoPontos)
        #fig_svg.setStrokeWidth(1)
        layer.renderer().symbol().changeSymbolLayer(0, fig_svg )
        QgsProject.instance().addMapLayer(layer)
        self.showLabel(layer, "label")
        #layer.triggerRepaint()

    def writeMemRoos(self):
        #print(self.controle_pagina)
        with open(self.dlg.mQgsFileWidget.filePath()+'\\memoria.roos', 'w') as f:
            f.write(f'{self.controle_pagina}\n{self.mem}\n{self.mem_adicional}')
    
    def viagemTempo(self):
        with open(self.dlg.mQgsFileWidget.filePath()+'\\memoria.roos', 'r') as f:
            lista_tempo = [x.rstrip('\n') for x in f]

        self.controle_pagina = ast.literal_eval(lista_tempo[0])-1 #int(lista_tempo[0])
        self.mem = ast.literal_eval(lista_tempo[1]) #list(lista_tempo[1].split("\'"))
        self.mem_adicional = ast.literal_eval(lista_tempo[2]) #list(lista_tempo[2].split("\'"))
        self.carregarMemCheckBox(self.controle_pagina, 1)

        self.angulo = 90
        if self.controle_pagina < len(self.onlyImages):
            endereco_photo = self.onlyImages[self.controle_pagina]
            nome_photo = self.imagesNames[self.controle_pagina]
            self.dlg.label_nome_foto.setText(nome_photo)
            self.selectPoint(nome_photo)
            self.new_photo = QPixmap(endereco_photo)
            self.dlg.photo.setPixmap(self.new_photo)
            self.dlg.pushButton_2.setEnabled(True)
            self.controle_pagina += 1
            if self.controle_pagina == len(self.onlyImages):
                self.dlg.pushButton.setEnabled(False)
                self.dlg.button_box.setEnabled(True)
            if self.controle_pagina == 1:
                self.dlg.pushButton_2.setEnabled(False)

        else:
            print('erro volta no tempo')

    def alturaBarranco(self, layerFeature, n_botao):
        '''Retorna vetor ponto que será a letra correspondente a altura do barranco'''
        if n_botao == 12:
            altura = 'B'
            self.cont_B.append(1)
            cont_da_vez = len(self.cont_B)
        elif n_botao == 13:
            altura = 'M'
            self.cont_M.append(1)
            cont_da_vez = len(self.cont_M)
        else: #14
            altura = 'A'
            self.cont_A.append(1)
            cont_da_vez = len(self.cont_A)
        geo = layerFeature.geometry()
        centro = geo.centroid()
        letra = QgsVectorLayer(f"Point?crs=epsg:31982&field={self.atributo_guia}:integer&field={self.seq}:integer&field=Altura:string&index=no",f"Altura Barranco {layerFeature[self.atributo_guia]} {cont_da_vez}","memory")
        letra.startEditing()
        feature2 = QgsFeature()
        feature2.setGeometry(centro) 
        feature2.setAttributes([int(layerFeature[self.atributo_guia]), int(layerFeature[self.seq]), altura])
        letra.addFeature(feature2)
        letra.commitChanges()
        #QgsProject.instance().addMapLayer(letra)
        return letra


                #----pega fotos da pasta

    def loadPhotosLayout(self, path_):

        # funçao dentro da função. Para ordenar as fotos conforme os numers que estão no string
        # import re
        def atoi(text):
            return int(text) if text.isdigit() else text

        def natural_keys(text):
            '''
            alist.sort(key=natural_keys) sorts in human order
            http://nedbatchelder.com/blog/200712/human_sorting.html
            (See Toothy's implementation in the comments)
            '''
            #return [ atoi(c) for c in re.split(r'\((\d+)\)', text) ] #por numero dentro do parêntese
            return [ atoi(c) for c in re.split(r'(\d+)', text) ]   #dígito

        # def atoiCruzado(text):
        #     self.ordem_E

        # alist=[
        #     "something1",
        #     "something12",
        #     "something17",
        #     "something2",
        #     "something25",
        #     "something29"]

        # alist.sort(key=natural_keys)
        # print(alist)

        # ordem_E = [int(i['Seq']) for i in vetor_pts_Esquerda.getFeatures()]
        # ordem_D = []
        onlyImages_E = [ 1 for i in self.ordem_E]
        onlyImages_D = [ 1 for i in self.ordem_D]
        #imagesNames = []
        mypath = path_
        onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))] #lista se for file
        onlyfiles.sort(key=natural_keys) ####        <=============    para sequenciar fotos por (1)

        pattern = re.compile(r"\((\d+)\)")
        # for item in onlyfiles:
        #     print(pattern.findall(item))
        #print(onlyfiles)

        for f in onlyfiles:
            #print(path.abspath(f'{mypath}//{f}'))
            #print(mimetypes.guess_type(f))
            tipo_imagem = mimetypes.guess_type(f) 
            if tipo_imagem[0] == 'image/jpeg' or tipo_imagem[0] == 'image/png':
                n_da_foto = int(pattern.findall(f)[0])  #encontra o número da foto, conforme o padrão entre parênteses
                #print(n_da_foto)
                if n_da_foto in self.fotos_E:
                    #onlyImages_E.append(f'{mypath}//{f}')
                    for pt in self.ordem_E:
                        if pt[0] == n_da_foto:
                            posicao = pt[1]
                            index_ = posicao-1
                            onlyImages_E.pop(index_)
                            onlyImages_E.insert(index_,f'{mypath}//{f}') ### FOTOS JÁ ORDENADAS CONFORME 'Seq'
                else:
                    #onlyImages_D.append(f'{mypath}//{f}')
                    for pt in self.ordem_D:
                        if pt[0] == n_da_foto:
                            posicao = pt[1]
                            index_ = posicao-1
                            onlyImages_D.pop(index_)
                            onlyImages_D.insert(index_,f'{mypath}//{f}') ### FOTOS JÁ ORDENADAS CONFORME 'Seq'

                    #onlyImages_D.insert(0,f'{mypath}//{f}')
                #imagesNames.append(f)
            # if imghdr.what(path.abspath(f'{mypath}//{f}')):    #(path.join(mypath,f)):   #filetype.is_image(f):
            #     onlyImages.append(f'{mypath}//{f}')
            #     imagesNames.append(f)

        #print("imagens:", onlyImages_D)
        return onlyImages_E, onlyImages_D

    def criarLayout(self, nome_layout, path_completo_modelo, lista_path_imagens, lista_labels_em_Seq_imagens, lado_das_ocorrencias): #lista_nomes_imagens):
        #----abrir modelo layout pronto - Load template from file
        project = QgsProject.instance()
        layout = QgsPrintLayout(project)
        layout.initializeDefaults()  #importante para gerar imagem depois

        layout.setName(nome_layout)
        project.layoutManager().addLayout(layout)

        #tmpfile = 'F:\\USUARIO\\Desktop\\Romario\\Projetos\\oco\\Pranchas\\modelo.qpt'
        tmpfile = path_completo_modelo

        with open(tmpfile) as f:
            template_content = f.read()
        doc = QDomDocument()
        doc.setContent(template_content)

        #----adding picture and label text to existing items
        try:
            items, ok = layout.loadFromTemplate(doc, QgsReadWriteContext(), False)
        except:
            print("Layout já existente")

        #criar copias das listas para retornar o que precisa:
        lista_path_imagens_nova = [i for i in lista_path_imagens]
        lista_labels_nova = [i for i in lista_labels_em_Seq_imagens]
        
        quanti_fotos = len(lista_path_imagens)

        for item in items:
            if isinstance(item, QgsLayoutItemLabel):
                if item.text() == 'Título':
                    item.setText(f'Fotos do Levantamento de Ocorrências - Margem {lado_das_ocorrencias} e Leito')
                else:
                    #print(item.id())
                    id_manual = int(float(item.id()))  #int(item.text())
                    try:
                        #lista_labels = self.dic_lista_labels[id_manual]
                        lista_labels = lista_labels_em_Seq_imagens[id_manual - 1]
                        quanti_labels = len(lista_labels)
                        texto = 'Observação'

                        #c = "Observacao "
                        for quanti in range(quanti_labels):
                            if quanti == 0: #primeiro
                                texto = f"{texto} {lista_labels[0]}"# texto = f"{texto} {{}}"
                            elif quanti == quanti_labels-1: #ultimo
                                texto = f"{texto} e {lista_labels[-1]}"
                            else:
                                texto = f"{texto}, {lista_labels[quanti]}"
                        #print(lista_labels)
                        # texto.format(*lista_labels)
                        #texto = f'Foto {lista_nomes_imagens[id_manual - 1][:-4]} m'
                        item.setText(texto)
                        #self.lista_labels.pop(id_manual)
                        lista_labels_nova.remove(lista_labels_em_Seq_imagens[id_manual - 1])

                    except :
                        pass

            elif isinstance(item, QgsLayoutItemPicture):
                try:
                    path = lista_path_imagens[int(item.id()) - 1]
                    item.setPicturePath(path)
                    lista_path_imagens_nova.remove(path)
                except :
                    pass
        iface.openLayoutDesigner(layout)
        return quanti_fotos, lista_path_imagens_nova, lista_labels_nova

    def pranchasPergunta(self):
        box = QMessageBox()
        box.setIcon(QMessageBox.Question)
        box.setWindowTitle('Pranchas')
        box.setText('''Deseja que sejam criadas as pranchas?''')
        box.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
        buttonY = box.button(QMessageBox.Yes)
        buttonY.setText('SIM')
        buttonN = box.button(QMessageBox.No)
        buttonN.setText('NÃO')
        box.exec_()
        if box.clickedButton() == buttonY:
            return 1
        elif box.clickedButton() == buttonN:
            return 0

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback. so that it will only load when the plugin is started
        if self.first_start == True:
            #self.first_start = False
            self.dlg = OcoDialog()
            self.controle_pagina = 0
            self.angulo = 90

            checkBox_e_ImagensSVG =[[self.dlg.checkBox_viva_margem,'viva_margem.svg'],
                                    [self.dlg.checkBox_morta_margem,'morta_margem.svg'],
                                    [self.dlg.checkBox_acesso,'acesso.svg'],
                                    [self.dlg.checkBox_cerca,'cerca.svg'],
                                    [self.dlg.checkBox_rampa,'rampa.svg'],
                                    [self.dlg.checkBox_foz,'foz.svg'],
                                    [self.dlg.checkBox_eclusa,'eclusa.svg'],
                                    [self.dlg.checkBox_porto,'porto.svg'],
                                    [self.dlg.checkBox_lixo,'lixo.svg'],
                                    [self.dlg.checkBox_bomba,'bomba_irrigacao.svg'],
                                    [self.dlg.checkBox_regua,'regua.svg'],
                                    [self.dlg.checkBox_placa,'placa_diversas.svg'],
                                    [self.dlg.checkBox_ponte,'ponte.svg'],
                                    [self.dlg.checkBox_barranco,'barranco.svg'],
                                    [self.dlg.checkBox_balneario,'balneario.svg'],
                                    [self.dlg.checkBox_estaleiro,'estaleiro.svg'],
                                    [self.dlg.checkBox_trapiche,'trapiche.svg'],
                                    [self.dlg.checkBox_edificacao,'edificacao.svg'],
                                    [self.dlg.checkBox_animal_vivo,'animal_vivo.svg'],
                                    [self.dlg.checkBox_mangueira,'mangueira.svg'],
                                    [self.dlg.checkBox_queimada,'queimada.svg'],
                                    [self.dlg.checkBox_instalacao_diversas,'instalacao_diversas.svg'],
                                    [self.dlg.checkBox_lavoura,'lavoura.svg'],
                                    [self.dlg.checkBox_outros_diversos,'outros_diversos.svg'],
                                    [self.dlg.checkBox_rede_eletrica,'rede_eletrica.svg'],
                                    [self.dlg.checkBox_protecao_talude,'protecao_talude.svg'],
                                    [self.dlg.checkBox_fissura_arvore_viva,'fissura_arvore_viva.svg'],
                                    [self.dlg.checkBox_diversos_APP,'diversos_APP.svg'],
                                    [self.dlg.checkBox_fissura_barranco,'fissura_barranco.svg'],
                                    [self.dlg.checkBox_solapamento,'solapamento.svg'],
                                    [self.dlg.checkBox_animal_morto,'animal_morto.svg'],
                                    [self.dlg.checkBox_rede_alta_tensao,'rede_alta_tensao.svg'],
                                    [self.dlg.checkBox_acampamento,'acampamento.svg'],
                                    [self.dlg.checkBox_banco_areia,'banco_areia.svg'],
                                    [self.dlg.checkBox_banco_areia_tocos,'banco_areia_tocos.svg'],
                                    [self.dlg.checkBox_bioengenharia,'bioengenharia.svg'],
                                    [self.dlg.checkBox_bomba_desativada,'bomba_desativada.svg'],                       
                                    [self.dlg.checkBox_porto_animais,'porto_animais.svg'],
                                    [self.dlg.checkBox_abertura_canal,'abertura_canal.svg'],
                                    [self.dlg.checkBox_fissura_arvore_morta,'fissura_arvore_morta.svg'],
                                    [self.dlg.checkBox_terminal_minerio,'terminal_minerio.svg'],
                                    [self.dlg.checkBox_descarga_lavoura,'descarga_lavoura.svg'],
                                    [self.dlg.checkBox_descarga_esgoto,'descarga_esgoto.svg'],
                                    [self.dlg.checkBox_desmatamento_APP,'desmatamento_APP.svg'],
                                    [self.dlg.checkBox_captacao_domestica,'captacao_domestica.svg'],
                                    [self.dlg.checkBox_placa_advertencia,'placa_advertencia.svg'],
                                    [self.dlg.checkBox_placa_controle,'placa_controle.svg'],
                                    [self.dlg.checkBox_placa_sinalizacao,'placa_sinalizacao.svg'],
                                    [self.dlg.checkBox_referencia_local,'referencia_local.svg'],
                                    [self.dlg.checkBox_porto_caiques,'porto_caiques.svg'],
                                    [self.dlg.checkBox_posto_controle,'posto_controle.svg'],

                                    [self.dlg.checkBox_viva_leito,'viva_leito.svg'],
                                    [self.dlg.checkBox_morta_leito,'morta_leito.svg'],
                                    [self.dlg.checkBox_ilhota,'ilhota.svg'],
                                    [self.dlg.checkBox_rochas, 'rochas.svg'],
                                    [self.dlg.checkBox_espuma, 'espuma.svg'],
                                    [self.dlg.checkBox_ponte_leito, 'ponte.svg'],
                                    [self.dlg.checkBox_itaipava, 'itaipava.svg'],
                                    [self.dlg.checkBox_flutuacao_diversas, 'flutuacao_diversas.svg'],
                                    [self.dlg.checkBox_boia_sinalizacao, 'boia_sinalizacao.svg'],
                                    [self.dlg.checkBox_embalagens_perigosas, 'embalagens_perigosas.svg'],
                                    [self.dlg.checkBox_encalhe_embarcacao, 'encalhe_embarcacao.svg'],
                                    [self.dlg.checkBox_oleos, 'oleos.svg'],
                                    [self.dlg.checkBox_equipamento_pesca, 'equipamento_pesca.svg'],
                                    [self.dlg.checkBox_flutuacao_posto_controle, 'flutuacao_posto_controle.svg'],
                                    [self.dlg.checkBox_embarcacao, 'embarcacao.svg'],
                                    [self.dlg.checkBox_encalhe_diversos, 'encalhe_diversos.svg']]

            morfo_radioButtons = self.dlg.lista_radio_buttons

            self.lista_radioButtons = [i[0] for i in morfo_radioButtons]

            # essa lista controla o tamanho da matriz gerada para cada foto [[oco],[morfo]]. a quanti de oco em [[0],[morfo]]
            # considera checkBoxes de ambos margem e leito
            self.lista_checkBox = [i[0] for i in checkBox_e_ImagensSVG]

            ####  IMPORTANTE  ####
            self.quanti_checkBox_margem = len(self.dlg.lista_icones_margem)    # 51 total de ocos que podem ter no monitoramento

            self.lista_imagensSVG = [i[1] for i in checkBox_e_ImagensSVG]

            #comboBox apenas para leito
            self.lista_comboBox = [ self.dlg.comboBox_viva,
                                    self.dlg.comboBox_morta,
                                    self.dlg.comboBox_ilhota,
                                    self.dlg.comboBox_rochas, 
                                    self.dlg.comboBox_espuma, 
                                    self.dlg.comboBox_ponte,
                                    self.dlg.comboBox_itaipava, 
                                    self.dlg.comboBox_diversos, 
                                    self.dlg.comboBox_boia,
                                    self.dlg.comboBox_embalagens_perigosas, 
                                    self.dlg.comboBox_encalhe_embarcacao,
                                    self.dlg.comboBox_oleos,
                                    self.dlg.comboBox_equipamento_pesca,
                                    self.dlg.comboBox_flutuacao_posto_controle,
                                    self.dlg.comboBox_embarcacao,
                                    self.dlg.comboBox_encalhe_diversos]
            
            # quanti checkBox leito = quanti comboBox leito
            self.quanti_checkBox_leito = len(self.lista_comboBox) # 16 total de ocos do monitoramento

            # lista que memoriza o estado de cada foto
            # [foto[oco[],morfo[]]]  #[foto[oco,morfo]] dentro de oco 0 e 1 para clicados ou não
            # [[[]],[[]]
            self.mem = []

            # lista para guardar a posição dos leitos A, B, C, D e E
            self.mem_adicional = []

        # show the dialog
        self.dlg.show()

        # muda photo
        self.dlg.pushButton.clicked.connect(lambda: self.changePhotoForward(self.controle_pagina))
        self.dlg.pushButton_2.clicked.connect(lambda: self.changePhotoBackward(self.controle_pagina))

        # seleciona pasta e congela
        self.dlg.mQgsFileWidget.fileChanged.connect(self.inicial_fotos)

        # muda sentido da foto
        self.dlg.pushButton_3.clicked.connect(self.photoTurn)

        self.seq = 'Seq'

        # mensagem de confirmação ao usuário
        #self.dlg.finalizarButton.clicked.connect(self.confirmFinal)
        
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            fazerPrancha = 0
            if self.dlg.groupBox_oco_margem.isChecked():
                fazerPrancha = self.pranchasPergunta()   #vai perguntar ao usuário se quer fazer a prancha.

            self.memorizar(self.controle_pagina-1)
            # print(self.mem)
            # print(self.mem_adicional)

            # carregar as entradas
            pasta_de_trabalho = self.dlg.mQgsFileWidget.filePath()
            self.atributo_guia = self.dlg.comboBox_atr.currentText()
            # self.seq = 'Seq'

            vetor_pts_Esquerda = self.dlg.mMapLayerComboBox_2.currentLayer()
            vetor_pts_Esquerda.removeSelection()

            self.fotos_E = [int(i[self.atributo_guia]) for i in vetor_pts_Esquerda.getFeatures()]
            self.ordem_E = [ [int(i[self.atributo_guia]), int(i['Seq'])] for i in vetor_pts_Esquerda.getFeatures()] #[nfoto,seq]

            vetor_pts_Direita = self.dlg.mMapLayerComboBox_4.currentLayer()
            vetor_pts_Direita.removeSelection()

            self.ordem_D = [ [int(i[self.atributo_guia]), int(i['Seq'])] for i in vetor_pts_Direita.getFeatures()]

            caminho_vetor_pts_Direita = vetor_pts_Direita.dataProvider().dataSourceUri() #será usado como padrão
            self.pasta_vetor_pts = os.path.dirname(caminho_vetor_pts_Direita)

            vetor_margem_E = self.dlg.mMapLayerComboBox.currentLayer()
            vetor_margem_D = self.dlg.mMapLayerComboBox_3.currentLayer()
            
            #self.escala = self.dlg.mScaleWidget.scale()
            self.largura_media = int(self.dlg.larg_M_LineEdit.text()) #200
            self.tamanhoPontos = self.dlg.mQgsDoubleSpinBox.value()   #8 #15
            self.fatorEscala = self.tamanhoPontos * 4 #parece ter ficado bom para o distanciamento entre figuras
            
            listaLayersSaida_margem = [ [] for i in range(self.quanti_checkBox_margem) ]
            listaLayersSaida_leito = [ [] for i in range(self.quanti_checkBox_leito) ]

            self.cont_morfo_E = [] #listas para controlar a quantidade de morfo (pol. buffer) por lado 
            self.cont_morfo_D = []
            self.cont_B = []
            self.cont_M = []
            self.cont_A = []
            
            ##########
            # Margem #
            ##########
            lista_dist_pts_margem_D, lista_intersects_D = self.perpendicular(vetor_pts_Direita, vetor_margem_D)
            lista_dist_pts_margem_E, lista_intersects_E = self.perpendicular(vetor_pts_Esquerda, vetor_margem_E)
            lista_todas_ln_perp = lista_dist_pts_margem_D + lista_dist_pts_margem_E
            lista_ordem_todas_ln_perp = sorted(lista_todas_ln_perp, key=lambda ln_perp: ln_perp.getFeature(1)[self.atributo_guia])

            #print("mem:", len(self.mem), "linhas:", len(lista_ordem_todas_ln_perp))

            # for ln in lista_ordem_todas_ln_perp:
            #     QgsProject.instance().addMapLayer(ln)  #para ver as linhas de perpendicular() em ordem

            if self.dlg.groupBox_oco_margem.isChecked():
                cont_foto = 0
                for foto in self.mem: 
                    cont_dist_nova = self.fatorEscala
                    cont_oco = 0
                    cont_checkBox = 0
                    for checkBox in listaLayersSaida_margem:
                        if foto[0][cont_checkBox]:    #faz referencia a cada oco especifica e cada check box específico. ex: arvore viva
                            if cont_oco == 0:
                                layer = self.ocoUm(lista_ordem_todas_ln_perp[cont_foto]) #, self.todos_n_fotos_ordem[cont_foto])
                                checkBox.append(layer)
                                cont_oco += 1
                            else:
                                layer = self.maisOco(lista_ordem_todas_ln_perp[cont_foto], cont_dist_nova) #, self.todos_n_fotos_ordem[cont_foto])
                                checkBox.append(layer)
                                cont_dist_nova += self.fatorEscala
                        cont_checkBox += 1
                    cont_foto += 1 

                ### Lista que armazenará info p/ -- PRANCHAS --
                dic_lista_labels = {}
                for lista in listaLayersSaida_margem:
                    for layer in lista:
                        for feat in layer.getFeatures():
                            #feat['label']
                            dic_lista_labels[feat[self.atributo_guia]] = [[feat['label']], feat['Seq']]
                            #self.lista_labels.append(feat[self.atributo_guia])
                            #self.lista_labels.append(feat['label'])
                #print(dic_lista_labels)
                #faz merge de todos os layer que são do mesmo tipo de ocorrencia e carrega SVG
                for checkBox in listaLayersSaida_margem:
                    if checkBox != []:
                        try:
                            merge = processing.run("native:mergevectorlayers", {'LAYERS':checkBox,
                                                                                'CRS':None,
                                                                                'OUTPUT':'TEMPORARY_OUTPUT'})
                            self.simbologiaSVG(merge['OUTPUT'], self.lista_imagensSVG[listaLayersSaida_margem.index(checkBox)]) 
                        except :
                            print('Except: MARGEM Merge Error')
                            for layer_separado in checkBox:
                                self.simbologiaSVGTemp(layer_separado, self.lista_imagensSVG[listaLayersSaida_margem.index(checkBox)])

            #########
            # Leito #
            #########
            lista_ln_leito_D = self.linhaOcoLeito(lista_dist_pts_margem_D, vetor_margem_D, vetor_margem_E)
            lista_ln_leito_E = self.linhaOcoLeito(lista_dist_pts_margem_E, vetor_margem_E, vetor_margem_D)
            lista_todas_ln_leito = []
            lista_todas_ln_leito = lista_ln_leito_D + lista_ln_leito_E
            lista_ordem_todas_ln_leito = sorted(lista_todas_ln_leito, key=lambda ln_perp: ln_perp.getFeature(1)[self.atributo_guia])  #ordena vetores conforme o id 

            # # for ln in lista_ordem_todas_ln_leito:
            # #     QgsProject.instance().addMapLayer(ln)

            # #mem_adicional correspondente as seleções do usuário referente a posição no leito A ou E = 0, B ou D = 1, C = 2
            # # mem_adicional = [[1,0,2],[0,1,1],[0,0,1],[1,1,1]] #,[1,1,1],[0,0,0],[0,0,0],[1,2,2],[1,2,1],[0,2,1]]
            if self.dlg.groupBox_oco_margem.isChecked():
                cont_foto = 0
                for foto in self.mem:                            #################
                    cont_checkBox = self.quanti_checkBox_margem  #### atenção ####   <------- quant checkBox de margem
                    for checkBox in listaLayersSaida_leito: 
                        if foto[0][cont_checkBox]: # leito começava em foto[0][3]
                            layer = self.ocoLeito(lista_ordem_todas_ln_leito[cont_foto], self.mem_adicional[cont_foto][cont_checkBox-self.quanti_checkBox_margem]) # esse index [0] é referente ao indece na mem_adicional, que por sua vez faz referencia à A, B, C, D ou E escolhido pelo usuário
                            checkBox.append(layer)
                        cont_checkBox += 1
                    cont_foto += 1

                # for lista in listaLayersSaida_leito:
                #     for ln in lista:
                #         QgsProject.instance().addMapLayer(ln)

                ### Lista que armazenará info p/ -- PRANCHAS --
                #self.lista_labels = {}
                for lista in listaLayersSaida_leito:
                    for layer in lista:
                        for feat in layer.getFeatures():
                            #label = feat['label']
                            #self.lista_labels[feat[self.atributo_guia]] = [feat['label']]
                            try: #adiciona ao existente
                                dic_lista_labels[feat[self.atributo_guia]][0].append(feat['label']) 
                                #print(dic_lista_labels[feat[self.atributo_guia]])
                            #dic_lista_labels[feat[self.atributo_guia]][0].append(feat['Seq'])
                            except: #caso não tenha, cria novo
                                #print(dic_lista_labels[feat[self.atributo_guia]])
                                dic_lista_labels[feat[self.atributo_guia]] = [[feat['label']], feat['Seq']]
                #print(self.lista_labels)
                #print(dic_lista_labels)

                #faz merge de todos os layer que são do mesmo tipo de ocorrencia e carrega SVG
                for checkBox in listaLayersSaida_leito:
                    #print(checkBox)
                    if checkBox != []:
                        try:
                            merge = processing.run("native:mergevectorlayers", {'LAYERS':checkBox,
                                                                                'CRS':None,
                                                                                'OUTPUT':'TEMPORARY_OUTPUT'})
                            self.simbologiaSVG(merge['OUTPUT'], self.lista_imagensSVG[listaLayersSaida_leito.index(checkBox)+self.quanti_checkBox_margem])  #### atencao             
                        except :
                            print('Except: LEITO Merge Error')
                            for layer_separado in checkBox:
                                self.simbologiaSVGTemp(layer_separado, self.lista_imagensSVG[listaLayersSaida_leito.index(checkBox)+self.quanti_checkBox_margem])

            
            if self.dlg.groupBox_morfo.isChecked():
                #############
                ##  MORFO  ##
                #############

                # ---------- esquerda
                # offset da margem. Para que as linhas sejam criadas. distancia negativa é para a esquerda
                offset_margem_E = processing.run("native:offsetline", {'INPUT':vetor_margem_E,
                                                                    'DISTANCE':-50,
                                                                    'SEGMENTS':8,
                                                                    'JOIN_STYLE':1,
                                                                    'MITER_LIMIT':2,
                                                                    'OUTPUT':'TEMPORARY_OUTPUT'})

                ###  ->  esta sequencia deve ser conforme a ordem dos labels do layout e não dos pontos
                lista_ordem_instersects_E = sorted(lista_intersects_E, key=lambda ponto: ponto.getFeature(1)[self.seq])  #ordena vetores conforme seq
                lista_linhas_buffer_E = self.linhasAreaFoto(lista_ordem_instersects_E, vetor_margem_E, offset_margem_E['OUTPUT'])
                # for linha in lista_linhas_buffer_E:
                #     QgsProject.instance().addMapLayer(linha)

                poligonos_morfo_E_1 = self.bufferNumerado(vetor_margem_E, 0, lista_linhas_buffer_E, lista_dist_pts_margem_E, vetor_pts_Esquerda)
                poligonos_morfo_E_2 = self.bufferNumerado(vetor_margem_E, 1, lista_linhas_buffer_E, lista_dist_pts_margem_E, vetor_pts_Esquerda)
                # QgsProject.instance().addMapLayer(poligonos_morfo_E_1)
                # QgsProject.instance().addMapLayer(poligonos_morfo_E_2)

                # ---------- direita
                # offset da margem. Para que as linhas sejam criadas. distancia negativa é para a esquerda
                offset_margem_D = processing.run("native:offsetline", {'INPUT':vetor_margem_D,
                                                                    'DISTANCE':50,
                                                                    'SEGMENTS':8,
                                                                    'JOIN_STYLE':1,
                                                                    'MITER_LIMIT':2,
                                                                    'OUTPUT':'TEMPORARY_OUTPUT'})

                ###  ->  esta sequencia deve ser conforme a ordem dos labels do layout e não dos pontos
                lista_ordem_instersects_D = sorted(lista_intersects_D, key=lambda ponto: ponto.getFeature(1)[self.seq])  #ordena vetores conforme seq
                lista_linhas_buffer_D = self.linhasAreaFoto(lista_ordem_instersects_D, vetor_margem_D, offset_margem_D['OUTPUT'])
                # for linha in lista_linhas_buffer_D:
                #     QgsProject.instance().addMapLayer(linha)

                poligonos_morfo_D_1 = self.bufferNumerado(vetor_margem_D, 0, lista_linhas_buffer_D, lista_dist_pts_margem_D, vetor_pts_Direita)
                poligonos_morfo_D_2 = self.bufferNumerado(vetor_margem_D, 1, lista_linhas_buffer_D, lista_dist_pts_margem_D, vetor_pts_Direita)
                # QgsProject.instance().addMapLayer(poligonos_morfo_D_1)
                # QgsProject.instance().addMapLayer(poligonos_morfo_D_2)

                lista_pol_morfo = [poligonos_morfo_E_1, poligonos_morfo_E_2, poligonos_morfo_D_1, poligonos_morfo_D_2]
                lista_caregorias = [[] for i in lista_pol_morfo]
                lista_altura_barranco = [['B.svg'],['M.svg'],['A.svg']] #[vetor_ponto_letra, nome_da_figura.svg]
                #lista_altura_barranco = [['B.svg'],['M.svg'],['A.svg'],['B.svg'],['M.svg'],['A.svg']] 
                cont_foto = 0
                for foto in self.mem:
                    cont_radioButton = 0
                    for radioButton in morfo_radioButtons: 
                        if foto[1][cont_radioButton]:
                            if cont_radioButton >= 12:  #### ATENCAO: os 3 últimos (de 15) não são cores
                                #para esses radioButton, cria os pontos que serão as letras
                                cont_morfo = 0
                                for pol_morfo in lista_pol_morfo:
                                    for poligono in pol_morfo.getFeatures():
                                        if poligono[self.atributo_guia] == cont_foto + 1:
                                            #if cont_morfo %2 == 0:
                                                #print('cont_morfo PAR:', cont_morfo) 
                                            if cont_radioButton == 12: # se for botao B
                                                #lista_altura_barranco.append([self.alturaBarranco(poligono, cont_radioButton),'B.svg'])
                                                lista_altura_barranco[0].append(self.alturaBarranco(poligono, cont_radioButton))
                                            elif cont_radioButton == 13:
                                                #lista_altura_barranco.append([self.alturaBarranco(poligono, cont_radioButton),'M.svg'])
                                                lista_altura_barranco[1].append(self.alturaBarranco(poligono, cont_radioButton))
                                            else: #14
                                                #lista_altura_barranco.append([self.alturaBarranco(poligono, cont_radioButton),'A.svg'])
                                                lista_altura_barranco[2].append(self.alturaBarranco(poligono, cont_radioButton))
                                            # else:
                                            #     print('cont_morfo IMPAR:', cont_morfo)
                                            #     if cont_radioButton == 12: # se for botao B
                                            #         #lista_altura_barranco.append([self.alturaBarranco(poligono, cont_radioButton),'B.svg'])
                                            #         lista_altura_barranco[3].append(self.alturaBarranco(poligono, cont_radioButton))
                                            #     elif cont_radioButton == 13:
                                            #         #lista_altura_barranco.append([self.alturaBarranco(poligono, cont_radioButton),'M.svg'])
                                            #         lista_altura_barranco[4].append(self.alturaBarranco(poligono, cont_radioButton))
                                            #     else: #14
                                            #         #lista_altura_barranco.append([self.alturaBarranco(poligono, cont_radioButton),'A.svg'])
                                            #         lista_altura_barranco[5].append(self.alturaBarranco(poligono, cont_radioButton))
                                    cont_morfo += 1
                            else: #para os outros radioButtons, 
                                for pol_morfo in lista_pol_morfo:
                                    for poligono in pol_morfo.getFeatures():
                                        if poligono[self.atributo_guia] == cont_foto + 1:
                                            symbol = QgsFillSymbol.createSimple({'color': radioButton[2], 'outline_color': radioButton[2]})
                                            categoria = QgsRendererCategory(poligono[self.atributo_guia], symbol, radioButton[1], True)
                                            lista_caregorias[lista_pol_morfo.index(pol_morfo)].append(categoria)
                                            #print(f"Foto: {cont_foto + 1}", f'color: {radioButton[2]}', f'outline_color: {radioButton[2]}')

                        cont_radioButton += 1
                    cont_foto += 1
                
                ##### FINALIZANDO MORFO. ou salva ou faz temporario
                
                ### POLIGONOS morfo
                for layer in lista_pol_morfo:
                    try: ### saving layer
                        save_options = QgsVectorFileWriter.SaveVectorOptions()
                        save_options.driverName = "ESRI Shapefile"
                        save_options.fileEncoding = "UTF-8"
                        transform_context = QgsProject.instance().transformContext()
                        layer_path = os.path.abspath(self.pasta_vetor_pts)
                        write_layer = QgsVectorFileWriter.writeAsVectorFormatV2(layer,
                                                                        f'{layer_path}\\{layer.name()}',
                                                                        transform_context,
                                                                        save_options)
                        new_Layer = QgsVectorLayer(f'{layer_path}\\{layer.name()}.shp', layer.name(), "ogr")
                        QgsProject.instance().addMapLayer(new_Layer)
                        renderer = QgsCategorizedSymbolRenderer(self.atributo_guia, lista_caregorias[lista_pol_morfo.index(layer)])
                        new_Layer.setRenderer(renderer)
                        new_Layer.triggerRepaint()

                    except :
                        ###  layer temporários
                        #for layer in lista_pol_morfo:
                        QgsProject.instance().addMapLayer(layer)
                        renderer = QgsCategorizedSymbolRenderer(self.atributo_guia, lista_caregorias[lista_pol_morfo.index(layer)])
                        layer.setRenderer(renderer)
                        layer.triggerRepaint()


                ### NOMENCLATURA de altura dos barrancos
                # fazer o merge das alturas
                for lista in lista_altura_barranco:
                    if len(lista) != 1:  #caso não haja B, M ou A
                        try:
                            merge_altura = processing.run("native:mergevectorlayers",  {'LAYERS':lista[1:],
                                                                                        'CRS':None,
                                                                                        'OUTPUT':'TEMPORARY_OUTPUT'})
                            save_options = QgsVectorFileWriter.SaveVectorOptions()
                            save_options.driverName = "ESRI Shapefile"
                            save_options.fileEncoding = "UTF-8"
                            transform_context = QgsProject.instance().transformContext()
                            layer = merge_altura['OUTPUT']
                            layer.setName(lista[0][0])  # letra correspondente
                            layer_path = os.path.abspath(self.pasta_vetor_pts)
                            write_layer = QgsVectorFileWriter.writeAsVectorFormatV2(layer,
                                                                            f'{layer_path}\\{layer.name()}',
                                                                            transform_context,
                                                                            save_options)
                            new_Layer = QgsVectorLayer(f'{layer_path}\\{layer.name()}.shp', f'{layer.name()}', "ogr")
                            QgsProject.instance().addMapLayer(new_Layer)
                            self.showLabel(new_Layer, "Altura")
                            # layer_settings = QgsPalLayerSettings()
                            # text_format = QgsTextFormat()
                            # # text_format.setFont(QFont("Arial", 12))
                            # text_format.setSize(self.tamanhoPontos) #text_format.setSize(12)
                            # # buffer_settings = QgsTextBufferSettings()
                            # # buffer_settings.setEnabled(True)
                            # # buffer_settings.setSize(1)
                            # # buffer_settings.setColor(QColor("white"))
                            # # text_format.setBuffer(buffer_settings)
                            # layer_settings.setFormat(text_format)
                            # layer_settings.fieldName = "Altura"
                            # #layer_settings.placement = 2
                            # #layer_settings.enabled = True
                            # layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                            # new_Layer.renderer().symbol().setSize(0)
                            # new_Layer.setLabelsEnabled(True)
                            # new_Layer.setLabeling(layer_settings)
                            # new_Layer.triggerRepaint()

                        except:
                        ## fazer o merge das alturas
                        #for lista in lista_altura_barranco:
                            merge_altura = processing.run("native:mergevectorlayers",  {'LAYERS':lista[1:],
                                                                                        'CRS':None,
                                                                                        'OUTPUT':'TEMPORARY_OUTPUT'})
                            layer = merge_altura['OUTPUT']
                            layer.setName(lista[0][0])  # letra correspondente
                            QgsProject.instance().addMapLayer(layer)
                            self.showLabel(layer, "Altura")
                            # layer_settings = QgsPalLayerSettings()
                            # text_format = QgsTextFormat()
                            # # text_format.setFont(QFont("Arial", 12))
                            # text_format.setSize(self.tamanhoPontos) #text_format.setSize(12)
                            # # buffer_settings = QgsTextBufferSettings()
                            # # buffer_settings.setEnabled(True)
                            # # buffer_settings.setSize(1)
                            # # buffer_settings.setColor(QColor("white"))
                            # # text_format.setBuffer(buffer_settings)
                            # layer_settings.setFormat(text_format)
                            # layer_settings.fieldName = "Altura"
                            # #layer_settings.placement = 2
                            # #layer_settings.enabled = True
                            # layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                            # layer.renderer().symbol().setSize(0)
                            # layer.setLabelsEnabled(True)
                            # layer.setLabeling(layer_settings)
                            # layer.triggerRepaint()
            
            ##################
            ##   Pranchas   ##
            ##################
            if fazerPrancha == 1:
                modelo_qpt = f'{self.plugin_dir}\\modelo.qpt'
                caminho_Pasta_fotos = pasta_de_trabalho #'F:\\USUARIO\\Desktop\\Pranchas Gustavo\\Com escala'
                lista_path_imagens_E, lista_path_imagens_D = self.loadPhotosLayout(caminho_Pasta_fotos)
                #print('E ', lista_path_imagens_E, 'D: ', lista_path_imagens_D)
                lista_de_listas_labels_E = []
                lista_de_listas_labels_D = []
                

                ### Pranchas da ESQUERDA ###

                cont_layout = 1
                nome_do_layout = f"Prancha de Fotos (Folha {cont_layout})"

                # for i in range(quanti_fotos_layout):
                #     lista_labels_imagens.append(dic_lista_labels[i+1])

                #### TODO: Colocar try aqui para avisar erro caso tenha alguma foto sem ter sida marcada pelo usuario
                for foto in self.fotos_E:
                    #print(dic_lista_labels[foto])
                    lista_de_listas_labels_E.append(dic_lista_labels[foto])

                ### Ordenar os labels conforme 'Seq'

                lista_de_listas_labels_E = sorted(lista_de_listas_labels_E, key = lambda x: x[1])
                lista_labels_E = [ i[0] for i in lista_de_listas_labels_E] #diminui uma dimensão

                #print('labels E', lista_labels_E)

                n_fotos, lst_path_img_atualizada, lst_labels_atualizada = self.criarLayout(nome_do_layout, modelo_qpt, lista_path_imagens_E, lista_labels_E, 'Esquerda')
                #n_fotos, lst_path_img_atualizada = self.criarLayout(nome_do_layout, modelo_qpt, lista_path_das_imagens)

                # print("nfotos", n_fotos, "list path", lst_path_img_atualizada,"lista nomes:", lst_nome_img_atualizada)

                #### faz mais que 20 fotos
                quanti_layouts_necessarios = math.ceil(n_fotos/20)
                if quanti_layouts_necessarios > 1:
                    cont_layout = 2
                    for i in range(quanti_layouts_necessarios-1):
                        nome_do_layout = f"Prancha de Fotos (Folha {cont_layout})"
                        n_fotos, lst_path_img_atualizada, lst_labels_atualizada = self.criarLayout(nome_do_layout, modelo_qpt, lst_path_img_atualizada, lst_labels_atualizada, 'Esquerda')
                        #n_fotos, lst_path_img_atualizada = self.criarLayout(nome_do_layout, modelo_qpt, lst_path_img_atualizada)
                        cont_layout += 1
                else:
                    cont_layout = 2


                ### Pranchas da DIREITA ###

                nome_do_layout = f"Prancha de Fotos (Folha {cont_layout})"
                quanti_fotos_layout = len(dic_lista_labels)

                for i in range(quanti_fotos_layout):
                    if i+1 not in self.fotos_E:
                        lista_de_listas_labels_D.append(dic_lista_labels[i+1])

                lista_de_listas_labels_D = sorted(lista_de_listas_labels_D, key = lambda x: x[1])
                lista_labels_D = [ i[0] for i in lista_de_listas_labels_D] #diminui uma dimensão

                #print('labels D', lista_labels_D)

                n_fotos, lst_path_img_atualizada, lst_labels_atualizada = self.criarLayout(nome_do_layout, modelo_qpt, lista_path_imagens_D, lista_labels_D, 'Direita')
                #n_fotos, lst_path_img_atualizada = self.criarLayout(nome_do_layout, modelo_qpt, lista_path_das_imagens)

                # print("nfotos", n_fotos, "list path", lst_path_img_atualizada,"lista nomes:", lst_nome_img_atualizada)

                #### faz mais que 20 fotos
                quanti_layouts_necessarios = math.ceil(n_fotos/20)
                if quanti_layouts_necessarios > 1:
                    #cont_layout = 2
                    cont_layout += 1
                    for i in range(quanti_layouts_necessarios-1):
                        nome_do_layout = f"Prancha de Fotos (Folha {cont_layout})"
                        n_fotos, lst_path_img_atualizada, lst_labels_atualizada = self.criarLayout(nome_do_layout, modelo_qpt, lst_path_img_atualizada, lst_labels_atualizada, 'Direita')
                        #n_fotos, lst_path_img_atualizada = self.criarLayout(nome_do_layout, modelo_qpt, lst_path_img_atualizada)
                        cont_layout += 1




        else:  #ao cancelar o programa
            vetor_pts_Esquerda = self.dlg.mMapLayerComboBox_2.currentLayer()
            if vetor_pts_Esquerda is not None:
                vetor_pts_Esquerda.removeSelection()
            vetor_pts_Direita = self.dlg.mMapLayerComboBox_4.currentLayer()
            if vetor_pts_Direita is not None:
                vetor_pts_Direita.removeSelection()







                ## depricated
                # for altura in lista_altura_barranco:
                #     self.simbologiaAlturaBarranco(altura[1], altura[0])
                #     QgsProject.instance().addMapLayer(altura[1])
                # #QgsProject.instance().reloadAllLayers()


    ## depricated. funcionou no computador em casa, mas no trabalh não
    # def simbologiaAlturaBarranco(self, layer, nomeFiguraSVG):
    #     ##saving layer
    #     # try:
    #     #     save_options = QgsVectorFileWriter.SaveVectorOptions()
    #     #     save_options.driverName = "ESRI Shapefile"
    #     #     save_options.fileEncoding = "UTF-8"
    #     #     transform_context = QgsProject.instance().transformContext()
    #     #     layer_path = os.path.abspath(self.pasta_vetor_pts) #C:/Users/Dell/Desktop/Projetos/oco/Oco_plugin/Banco OCO/SHP
    #     #     write_layer = QgsVectorFileWriter.writeAsVectorFormatV2(layer,
    #     #                                                     f'{layer_path}\\{layer.name()}',
    #     #                                                     transform_context,
    #     #                                                     save_options)
    #     #     path = f'{self.plugin_dir}\\imagens\\{nomeFiguraSVG}'  #'C:\\Program Files\\QGIS 3.10\\apps\\qgis-ltr\\svg\\oco\\viva_margem.svg'
    #     #     fig_svg = QgsSvgMarkerSymbolLayer(path)
    #     #     fig_svg.setSize(self.tamanhoPontos)
    #     #     #fig_svg.setStrokeWidth(1)
    #     #     new_Layer = QgsVectorLayer(f'{layer_path}\\{layer.name()}.shp', layer.name(), "ogr")
    #     #     new_Layer.renderer().symbol().changeSymbolLayer(0, fig_svg )
    #     #     QgsProject.instance().addMapLayer(new_Layer)
    #     #     new_Layer.triggerRepaint()
    #     # except:
    #     ## temporário
    #     print('Except: Erro simbologiaAlturaBarranco')
        
    #     path = f'{self.plugin_dir}\\imagens\\{nomeFiguraSVG}'  #'C:\\Program Files\\QGIS 3.10\\apps\\qgis-ltr\\svg\\oco\\viva_margem.svg'
    #     # path = os.path.join(f'{self.plugin_dir}\\imagens', nomeFiguraSVG)
    #     #print(path)
    #     fig_svg = QgsSvgMarkerSymbolLayer(path)
    #     fig_svg.setSize(self.tamanhoPontos)
    #     # fig_svg.setFillColor(QColor('#0000ff'))
    #     # fig_svg.setStrokeColor(QColor('#ff0000'))
    #     # fig_svg.setStrokeWidth(1)
    #     layer.renderer().symbol().changeSymbolLayer(0, fig_svg )
    #     QgsProject.instance().addMapLayer(layer)
    #     layer.triggerRepaint()


    # def confirmFinal(self):
    #     box = QMessageBox()
    #     box.setIcon(QMessageBox.Warning)
    #     box.setWindowTitle('Finalizar')
    #     box.setText('Deseja finalizar e gerar os layouts?')
    #     box.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
    #     buttonY = box.button(QMessageBox.Yes)
    #     buttonY.setText('SIM')
    #     buttonN = box.button(QMessageBox.No)
    #     buttonN.setText('NÃO')
    #     box.exec_()
    #     if box.clickedButton() == buttonY:
    #         self.memorizar(self.controle_pagina-1)
    #         print(self.mem)
    #         #run()
    #         self.dlg.accept()




### TODO:     add mensagem de memória incompatível caso o número de fotos não seja igual ao de memórias
###           ADD um arquivo tipo log para saber as entradas. Talvez no relatório


                ## TODO: fazer com que merge as alturas por morfo, assim fica fácil na hora de excluir os que estão a mais
############ coloquei essa formula no single label, onde Seq é o valor que está no atributo "Seq"
#if( is_selected( ), label, NULL)
# FAZ LABEL PARA os que estão selecionados apenas. então selecionar na tabela de atributo ou manualmente
# os labels mais que queremos mostrar.

### verificar a possibilidade d, quando for a última oco do, adicionar um field onde só esse atributo conterá um valor
# assim talvez seja possivel fazer layout mais rápido 


## partir para pranchas

## pensar em check box para usuario escolher se quer oco ou morfo ou pranchas

## BUG estudar o caso da ilha menor de 810_709_2016 e 810_710_2016 AM( PK116,5 a 119) pois na ponta da ilha
# está dando geometria nula pois não encosat na margem, porém visualmente deveria ter encostado
# arrumei esse bug aumentando a estensao da linha até as margens. o que aconteceu foi que uns pontos simplesmente decidiram extender para o outro lado, então estendi 
# para ambos os lados.
# também é importante deixar as linhas de margem beeem mais compridas do que os pontos. criar logica para extender as margensa

# escrever nas instruções que os shapes serão gravados onde estão os pontos, mais especificamente os pontos da direita

# permitir ao usuário mudar o tamanho do ponto. deixar 15 como padrão
# pensar em formas de melhorar a proporção da escala.
# criar lógica que considera a distancias entre ops pontos para determinar o tamanho do ponto. não considerar as maiores distancias

### MORFO:
# criar um pré processamento que ordena as margens. isso será importante para determinar o lado do buffer para a morfo

###OBS: mudei as linhas 684 do algoritmo para usar o que é melho. eu tinha trocado antes. eStou anotando caso ocorra algum bug 
# na geração das próximas morfos.